// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gx_test.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using scg = global::System.Collections.Generic;
namespace gx_test {

  #region Messages
  public sealed class gx_data : pb::IMessage {
    private static readonly pb::MessageParser<gx_data> _parser = new pb::MessageParser<gx_data>(() => new gx_data());
    public static pb::MessageParser<gx_data> Parser { get { return _parser; } }

    private double sc_double_;
    /// <summary>
    ///*************test scalar********************
    /// </summary>
    public double sc_double {
      get { return sc_double_; }
      set {
        sc_double_ = value;
      }
    }

    private float sc_float_;
    public float sc_float {
      get { return sc_float_; }
      set {
        sc_float_ = value;
      }
    }

    private int sc_int32_;
    public int sc_int32 {
      get { return sc_int32_; }
      set {
        sc_int32_ = value;
      }
    }

    private long sc_int64_;
    /// <summary>
    ///long
    /// </summary>
    public long sc_int64 {
      get { return sc_int64_; }
      set {
        sc_int64_ = value;
      }
    }

    private uint sc_uint32_;
    public uint sc_uint32 {
      get { return sc_uint32_; }
      set {
        sc_uint32_ = value;
      }
    }

    private ulong sc_uint64_;
    /// <summary>
    ///ulong
    /// </summary>
    public ulong sc_uint64 {
      get { return sc_uint64_; }
      set {
        sc_uint64_ = value;
      }
    }

    private int sc_sint32_;
    public int sc_sint32 {
      get { return sc_sint32_; }
      set {
        sc_sint32_ = value;
      }
    }

    private long sc_sint64_;
    public long sc_sint64 {
      get { return sc_sint64_; }
      set {
        sc_sint64_ = value;
      }
    }

    private uint sc_fixed32_;
    public uint sc_fixed32 {
      get { return sc_fixed32_; }
      set {
        sc_fixed32_ = value;
      }
    }

    private ulong sc_fixed64_;
    public ulong sc_fixed64 {
      get { return sc_fixed64_; }
      set {
        sc_fixed64_ = value;
      }
    }

    private int sc_sfixed32_;
    public int sc_sfixed32 {
      get { return sc_sfixed32_; }
      set {
        sc_sfixed32_ = value;
      }
    }

    private long sc_sfixed64_;
    public long sc_sfixed64 {
      get { return sc_sfixed64_; }
      set {
        sc_sfixed64_ = value;
      }
    }

    private bool sc_bool_;
    public bool sc_bool {
      get { return sc_bool_; }
      set {
        sc_bool_ = value;
      }
    }

    private string sc_string_ = "";
    public string sc_string {
      get { return sc_string_; }
      set {
        sc_string_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private pb::ByteString sc_bytes_ = pb::ByteString.Empty;
    public pb::ByteString sc_bytes {
      get { return sc_bytes_; }
      set {
        sc_bytes_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private global::gx_test.gx_data.MyEnum t_enum_ = 0;
    public global::gx_test.gx_data.MyEnum t_enum {
      get { return t_enum_; }
      set {
        t_enum_ = value;
      }
    }

    private global::gx_test.gx_data.MyEnum2 t_enum_2_ = 0;
    public global::gx_test.gx_data.MyEnum2 t_enum_2 {
      get { return t_enum_2_; }
      set {
        t_enum_2_ = value;
      }
    }

    private global::gx_test.gx_data_type t_class_;
    /// <summary>
    ///*************test type********************
    /// </summary>
    public global::gx_test.gx_data_type t_class {
      get { return t_class_; }
      set {
        t_class_ = value;
      }
    }

    private global::gx_test.gx_data.gx_data_nested t_nest_type_;
    public global::gx_test.gx_data.gx_data_nested t_nest_type {
      get { return t_nest_type_; }
      set {
        t_nest_type_ = value;
      }
    }

    private static readonly pb::FieldCodec<int> _repeated_rep_int32_codec
        = pb::FieldCodec.ForInt32(162);
    private readonly pbc::RepeatedField<int> rep_int32_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///*************test repeated fields********************
    /// </summary>
    public pbc::RepeatedField<int> rep_int32 {
      get { return rep_int32_; }
    }

    private static readonly pb::FieldCodec<string> _repeated_rep_string_codec
        = pb::FieldCodec.ForString(170);
    private readonly pbc::RepeatedField<string> rep_string_ = new pbc::RepeatedField<string>();
    public pbc::RepeatedField<string> rep_string {
      get { return rep_string_; }
    }

    private static readonly pb::FieldCodec<pb::ByteString> _repeated_rep_bytes_codec
        = pb::FieldCodec.ForBytes(178);
    private readonly pbc::RepeatedField<pb::ByteString> rep_bytes_ = new pbc::RepeatedField<pb::ByteString>();
    public pbc::RepeatedField<pb::ByteString> rep_bytes {
      get { return rep_bytes_; }
    }

    private static readonly pb::FieldCodec<global::gx_test.gx_data.MyEnum> _repeated_rep_enum_codec
        = pb::FieldCodec.ForEnum(186, x => (int) x, x => (global::gx_test.gx_data.MyEnum) x);
    private readonly pbc::RepeatedField<global::gx_test.gx_data.MyEnum> rep_enum_ = new pbc::RepeatedField<global::gx_test.gx_data.MyEnum>();
    public pbc::RepeatedField<global::gx_test.gx_data.MyEnum> rep_enum {
      get { return rep_enum_; }
    }

    private static readonly pb::FieldCodec<global::gx_test.gx_data_type> _repeated_rep_type_codec
        = pb::FieldCodec.ForMessage(194, global::gx_test.gx_data_type.Parser);
    private readonly pbc::RepeatedField<global::gx_test.gx_data_type> rep_type_ = new pbc::RepeatedField<global::gx_test.gx_data_type>();
    public pbc::RepeatedField<global::gx_test.gx_data_type> rep_type {
      get { return rep_type_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (sc_double != 0D) {
        output.WriteRawTag(9);
        output.WriteDouble(sc_double);
      }
      if (sc_float != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(sc_float);
      }
      if (sc_int32 != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(sc_int32);
      }
      if (sc_int64 != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(sc_int64);
      }
      if (sc_uint32 != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(sc_uint32);
      }
      if (sc_uint64 != 0UL) {
        output.WriteRawTag(48);
        output.WriteUInt64(sc_uint64);
      }
      if (sc_sint32 != 0) {
        output.WriteRawTag(56);
        output.WriteSInt32(sc_sint32);
      }
      if (sc_sint64 != 0L) {
        output.WriteRawTag(64);
        output.WriteSInt64(sc_sint64);
      }
      if (sc_fixed32 != 0) {
        output.WriteRawTag(77);
        output.WriteFixed32(sc_fixed32);
      }
      if (sc_fixed64 != 0UL) {
        output.WriteRawTag(81);
        output.WriteFixed64(sc_fixed64);
      }
      if (sc_sfixed32 != 0) {
        output.WriteRawTag(93);
        output.WriteSFixed32(sc_sfixed32);
      }
      if (sc_sfixed64 != 0L) {
        output.WriteRawTag(97);
        output.WriteSFixed64(sc_sfixed64);
      }
      if (sc_bool != false) {
        output.WriteRawTag(104);
        output.WriteBool(sc_bool);
      }
      if (sc_string.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(sc_string);
      }
      if (sc_bytes.Length != 0) {
        output.WriteRawTag(122);
        output.WriteBytes(sc_bytes);
      }
      if (t_enum != 0) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) t_enum);
      }
      if (t_enum_2 != 0) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) t_enum_2);
      }
      if (t_class_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(t_class);
      }
      if (t_nest_type_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(t_nest_type);
      }
      rep_int32_.WriteTo(output, _repeated_rep_int32_codec);
      rep_string_.WriteTo(output, _repeated_rep_string_codec);
      rep_bytes_.WriteTo(output, _repeated_rep_bytes_codec);
      rep_enum_.WriteTo(output, _repeated_rep_enum_codec);
      rep_type_.WriteTo(output, _repeated_rep_type_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (sc_double != 0D) {
        size += 1 + 8;
      }
      if (sc_float != 0F) {
        size += 1 + 4;
      }
      if (sc_int32 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(sc_int32);
      }
      if (sc_int64 != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(sc_int64);
      }
      if (sc_uint32 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(sc_uint32);
      }
      if (sc_uint64 != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(sc_uint64);
      }
      if (sc_sint32 != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(sc_sint32);
      }
      if (sc_sint64 != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeSInt64Size(sc_sint64);
      }
      if (sc_fixed32 != 0) {
        size += 1 + 4;
      }
      if (sc_fixed64 != 0UL) {
        size += 1 + 8;
      }
      if (sc_sfixed32 != 0) {
        size += 1 + 4;
      }
      if (sc_sfixed64 != 0L) {
        size += 1 + 8;
      }
      if (sc_bool != false) {
        size += 1 + 1;
      }
      if (sc_string.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(sc_string);
      }
      if (sc_bytes.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(sc_bytes);
      }
      if (t_enum != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) t_enum);
      }
      if (t_enum_2 != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) t_enum_2);
      }
      if (t_class_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(t_class);
      }
      if (t_nest_type_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(t_nest_type);
      }
      size += rep_int32_.CalculateSize(_repeated_rep_int32_codec);
      size += rep_string_.CalculateSize(_repeated_rep_string_codec);
      size += rep_bytes_.CalculateSize(_repeated_rep_bytes_codec);
      size += rep_enum_.CalculateSize(_repeated_rep_enum_codec);
      size += rep_type_.CalculateSize(_repeated_rep_type_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 9: {
            sc_double = input.ReadDouble();
            break;
          }
          case 21: {
            sc_float = input.ReadFloat();
            break;
          }
          case 24: {
            sc_int32 = input.ReadInt32();
            break;
          }
          case 32: {
            sc_int64 = input.ReadInt64();
            break;
          }
          case 40: {
            sc_uint32 = input.ReadUInt32();
            break;
          }
          case 48: {
            sc_uint64 = input.ReadUInt64();
            break;
          }
          case 56: {
            sc_sint32 = input.ReadSInt32();
            break;
          }
          case 64: {
            sc_sint64 = input.ReadSInt64();
            break;
          }
          case 77: {
            sc_fixed32 = input.ReadFixed32();
            break;
          }
          case 81: {
            sc_fixed64 = input.ReadFixed64();
            break;
          }
          case 93: {
            sc_sfixed32 = input.ReadSFixed32();
            break;
          }
          case 97: {
            sc_sfixed64 = input.ReadSFixed64();
            break;
          }
          case 104: {
            sc_bool = input.ReadBool();
            break;
          }
          case 114: {
            sc_string = input.ReadString();
            break;
          }
          case 122: {
            sc_bytes = input.ReadBytes();
            break;
          }
          case 128: {
            t_enum_ = (global::gx_test.gx_data.MyEnum) input.ReadEnum();
            break;
          }
          case 136: {
            t_enum_2_ = (global::gx_test.gx_data.MyEnum2) input.ReadEnum();
            break;
          }
          case 146: {
            if (t_class_ == null) {
              t_class_ = new global::gx_test.gx_data_type();
            }
            input.ReadMessage(t_class_);
            break;
          }
          case 154: {
            if (t_nest_type_ == null) {
              t_nest_type_ = new global::gx_test.gx_data.gx_data_nested();
            }
            input.ReadMessage(t_nest_type_);
            break;
          }
          case 162:
          case 160: {
            rep_int32_.AddEntriesFrom(input, _repeated_rep_int32_codec);
            break;
          }
          case 170: {
            rep_string_.AddEntriesFrom(input, _repeated_rep_string_codec);
            break;
          }
          case 178: {
            rep_bytes_.AddEntriesFrom(input, _repeated_rep_bytes_codec);
            break;
          }
          case 186:
          case 184: {
            rep_enum_.AddEntriesFrom(input, _repeated_rep_enum_codec);
            break;
          }
          case 194: {
            rep_type_.AddEntriesFrom(input, _repeated_rep_type_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the gx_data message type.</summary>
    public static class Types {
      /// <summary>
      ///*************test enum********************
      /// </summary>
      public enum MyEnum {
        enum_0 = 0,
        enum_1 = 1,
        enum_2 = 2,
        enum_7 = 7,
      }

      /// <summary>
      ///test Enum alias
      /// </summary>
      public enum MyEnum2 {
        enum_20 = 0,
        enum_21 = 11,
        enum_22 = 11,
      }

      /// <summary>
      ///test nested type
      /// </summary>
      public sealed class gx_data_nested : pb::IMessage {
        private static readonly pb::MessageParser<gx_data_nested> _parser = new pb::MessageParser<gx_data_nested>(() => new gx_data_nested());
        public static pb::MessageParser<gx_data_nested> Parser { get { return _parser; } }

        private string d_ = "";
        public string d {
          get { return d_; }
          set {
            d_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (d.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(d);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (d.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(d);
          }
          return size;
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                d = input.ReadString();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed class gx_data_type : pb::IMessage {
    private static readonly pb::MessageParser<gx_data_type> _parser = new pb::MessageParser<gx_data_type>(() => new gx_data_type());
    public static pb::MessageParser<gx_data_type> Parser { get { return _parser; } }

    private float d1_;
    public float d1 {
      get { return d1_; }
      set {
        d1_ = value;
      }
    }

    private int d2_;
    public int d2 {
      get { return d2_; }
      set {
        d2_ = value;
      }
    }

    private string d3_ = "";
    public string d3 {
      get { return d3_; }
      set {
        d3_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private static readonly pb::FieldCodec<string> _repeated_d4_codec
        = pb::FieldCodec.ForString(322);
    private readonly pbc::RepeatedField<string> d4_ = new pbc::RepeatedField<string>();
    public pbc::RepeatedField<string> d4 {
      get { return d4_; }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (d1 != 0F) {
        output.WriteRawTag(85);
        output.WriteFloat(d1);
      }
      if (d2 != 0) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(d2);
      }
      if (d3.Length != 0) {
        output.WriteRawTag(242, 1);
        output.WriteString(d3);
      }
      d4_.WriteTo(output, _repeated_d4_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (d1 != 0F) {
        size += 1 + 4;
      }
      if (d2 != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(d2);
      }
      if (d3.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(d3);
      }
      size += d4_.CalculateSize(_repeated_d4_codec);
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 85: {
            d1 = input.ReadFloat();
            break;
          }
          case 160: {
            d2 = input.ReadInt32();
            break;
          }
          case 242: {
            d3 = input.ReadString();
            break;
          }
          case 322: {
            d4_.AddEntriesFrom(input, _repeated_d4_codec);
            break;
          }
        }
      }
    }

  }

  public sealed class gx_data3 : pb::IMessage {
    private static readonly pb::MessageParser<gx_data3> _parser = new pb::MessageParser<gx_data3>(() => new gx_data3());
    public static pb::MessageParser<gx_data3> Parser { get { return _parser; } }

    private global::gx_test_other.gx_data_other otherData_;
    public global::gx_test_other.gx_data_other otherData {
      get { return otherData_; }
      set {
        otherData_ = value;
      }
    }

    private int d_;
    public int d {
      get { return d_; }
      set {
        d_ = value;
      }
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (otherData_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(otherData);
      }
      if (d != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(d);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (otherData_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(otherData);
      }
      if (d != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(d);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (otherData_ == null) {
              otherData_ = new global::gx_test_other.gx_data_other();
            }
            input.ReadMessage(otherData_);
            break;
          }
          case 16: {
            d = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///************** test Oneof *******************
  /// </summary>
  public sealed class gx_data_oneof : pb::IMessage {
    private static readonly pb::MessageParser<gx_data_oneof> _parser = new pb::MessageParser<gx_data_oneof>(() => new gx_data_oneof());
    public static pb::MessageParser<gx_data_oneof> Parser { get { return _parser; } }

    public string name {
      get { return t_oneofCase_ == t_oneofOneofCase.name ? (string) t_oneof_ : ""; }
      set {
        t_oneof_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        t_oneofCase_ = t_oneofOneofCase.name;
      }
    }

    public int index {
      get { return t_oneofCase_ == t_oneofOneofCase.index ? (int) t_oneof_ : 0; }
      set {
        t_oneof_ = value;
        t_oneofCase_ = t_oneofOneofCase.index;
      }
    }

    private object t_oneof_;
    /// <summary>Enum of possible cases for the "t_oneof" oneof.</summary>
    public enum t_oneofOneofCase {
      None = 0,
      name = 1,
      index = 2,
    }
    private t_oneofOneofCase t_oneofCase_ = t_oneofOneofCase.None;
    public t_oneofOneofCase t_oneofCase {
      get { return t_oneofCase_; }
    }

    public void Cleart_oneof() {
      t_oneofCase_ = t_oneofOneofCase.None;
      t_oneof_ = null;
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (t_oneofCase_ == t_oneofOneofCase.name) {
        output.WriteRawTag(10);
        output.WriteString(name);
      }
      if (t_oneofCase_ == t_oneofOneofCase.index) {
        output.WriteRawTag(16);
        output.WriteInt32(index);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (t_oneofCase_ == t_oneofOneofCase.name) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(name);
      }
      if (t_oneofCase_ == t_oneofOneofCase.index) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(index);
      }
      return size;
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            name = input.ReadString();
            break;
          }
          case 16: {
            index = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
